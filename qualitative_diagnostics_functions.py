# -*- coding: utf-8 -*-
"""diagnostics_essence.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BQ8kQnZm_GzUVzZJr_y8k4s-eBASIuBz
"""

import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy import stats

def build_regressors(nBack,choices,rewards):
  nChoices = len(choices)
  reg_c = np.zeros(nBack)
  reg_r = np.zeros(nBack)
  reg_x = np.zeros(nBack)
  predictors = np.zeros((nChoices, 3*nBack))

  for trial_i in range(nChoices):
    predictors[trial_i] = np.concatenate((reg_c, reg_x, reg_r), axis=None)

    if choices[trial_i] == 0 and rewards[trial_i] == 1: #left reward
      c,x,r=-1,-1,1 
    elif choices[trial_i] == 0 and rewards[trial_i] == 0: #left & no reward
      c,x,r=-1,1,-1
    elif choices[trial_i] == 1 and rewards[trial_i] == 1: #right reward
      c,x,r=1,1,1
    elif choices[trial_i] == 1 and rewards[trial_i] == 0: #right & no reward
      c,x,r=1,-1,-1
    else:
      print("oh no things are bad")

    reg_c = np.concatenate((c,reg_c[:-1]),axis=None)
    reg_r = np.concatenate((r,reg_r[:-1]),axis=None)
    reg_x = np.concatenate((x,reg_x[:-1]),axis=None)
  
  return predictors

def bandits_glm(nBack,data):
  regressors = build_regressors(nBack,data['choices'],data['rewards'])
  glm_binom = sm.GLM(data['choices'],sm.add_constant(regressors),family=sm.families.Binomial())
  
  #running the model
  glm_result = glm_binom.fit()
  weights_py = glm_result.params 

  return weights_py

# left bias 
def compute_left_choice_bias(choices):
  nChoices=len(choices)
  left=0
  right=0
  for i in range(nChoices):
    if choices[i] == 0:
      left += 1 
    if choices[i] == 1:
      right += 1 
  
  fraction_left = left / (right+left)*100
  
  return fraction_left

# right bias
def compute_right_choice_bias(choices):
  nChoices=len(choices)
  left=0
  right=0
  for i in range(nChoices):
    if choices[i] == 0:
      left += 1 
    if choices[i] == 1:
      right += 1 
  
  fraction_right = right / (right+left)*100

  return fraction_right

def bias(choices):
  nChoices=len(choices)
  left=0
  right=0
  for i in range(nChoices):
    if choices[i] == 0:
      left += 1 
    if choices[i] == 1:
      right += 1 
  
  x_index = ['left', 'right']
  y_index = [left, right]

  return x_index, y_index

def compute_learning_curve(reward_probabilities, choices, window):
  reward_prob_diffs = np.diff(reward_probabilities[:,1])
  high_to_low = np.where(reward_prob_diffs > 0)[0]
  low_to_high = np.where(reward_prob_diffs < 0)[0]

  locked_choice_ensemble = np.zeros((0,window))

  #Gather up the choices for high-to-low
  for block_start_trial in high_to_low:
    choices_block = choices[block_start_trial:block_start_trial+window]
    if np.size([choices_block], axis=1) == window:
      locked_choice_ensemble = np.concatenate((locked_choice_ensemble,[choices_block]), axis=0)

  #Gather up the choices for low-to-high. Flip the choices 
  for block_start_trial in low_to_high:
    choices_block = choices[block_start_trial:block_start_trial+window]
    choices_block_flipped = 1-choices_block
    if np.size([choices_block_flipped],axis=1) == window:
      locked_choice_ensemble = np.concatenate((locked_choice_ensemble, [choices_block_flipped]), axis=0)

  learning_curve = np.mean(locked_choice_ensemble,0)

  return learning_curve

def bout_distribution(choices):
  # make a difference between the choices 
  choice_prob_diffs = np.diff(choices)
  # index list that includes the choice_prob_diffs
  choice_prob_diffs_index_array = np.where(choice_prob_diffs)

  list_of_bouts = []
  for i in range(len(choice_prob_diffs_index_array[0])):
    if i == 0:
      list_of_bouts.append(choices[0:choice_prob_diffs_index_array[0][0]+1])
    else: 
      list_of_bouts.append(choices[choice_prob_diffs_index_array[0][i-1]+1:choice_prob_diffs_index_array[0][i]+1])

  list_of_counted_bouts = []
  total_num_list_of_counted_bouts = len(list_of_bouts)
  for num in range(total_num_list_of_counted_bouts):
    list_of_counted_bouts.append(len(list_of_bouts[num]))
  
  bout_length = stats.cumfreq(list_of_counted_bouts, numbins=max(list_of_counted_bouts))
  normalized_bout_length = bout_length.cumcount/len(list_of_counted_bouts)
  x_axis = bout_length.lowerlimit + bout_length.binsize/2 + np.linspace(0,bout_length.binsize*bout_length.cumcount.size, 
                                                                    bout_length.cumcount.size)
  
  return x_axis, normalized_bout_length

def mean_bout_distribution(arrs):
  lens = [len(i) for i in arrs]
  arr = np.ma.empty((np.max(lens),len(arrs)))
  arr.mask = True
  for idx, l in enumerate(arrs):
      arr[:len(l),idx] = l
  return arr.mean(axis = -1), arr.std(axis=-1)

def choice_within_block(choices,reward_probabilities):
  #Find the reward probability blocks 
  reward_prob_diffs = np.diff(reward_probabilities[:,1])
  block_mark = np.where(reward_prob_diffs)[0]
  high_to_low = np.where(reward_prob_diffs > 0)[0]
  low_to_high = np.where(reward_prob_diffs < 0)[0]

  # 1. Zero to first block mark
  blocks = [choices[:block_mark[0]]]

  # 2. Blockmarks to end
  for i in range(len(block_mark)):
    # print('Trial ', i)
    
    if i < len(block_mark)-1: # Until 7
      theblock = choices[block_mark[i]+1:block_mark[i+1]]
      # print(theblock[0].shape)
      blocks.append(theblock)
      
    else: # 8
      theblock = choices[block_mark[i]+1:]
      # print(theblock[0].shape)
      blocks.append(theblock)

  # 3. For every block, count right and left choicees and normalize it  (left = 0, right =1 )

  trial_list=[]    

  for i in range(len(block_mark)):
    if reward_probabilities[block_mark[i],1] == 0.8:
      trial_list.append('right side reward')
    else:
      trial_list.append('left side reward')

  if reward_probabilities[block_mark[-1]+1,1] == 0.8:
    trial_list.append('right side reward')
  else:
    trial_list.append('left side reward')

  block_count = np.zeros((len(blocks),2))
  for i in range(len(blocks)):
    left = 0
    right = 0
    for j in range(len(blocks[i])):
      if blocks[i][j]==0:
        left += 1 
      else:
        right += 1
      block_count[i,0] = left
      block_count[i,1] = right

  for i in range(len(block_count)):
    block_count[i][0] = block_count[i][0]/(block_count[i][0] + block_count[i][1])*100
    block_count[i][1] = block_count[i][1]/(block_count[i][0] + block_count[i][1])*100

  left=[]
  right=[]
  for i in range(len(block_count)):
    left.append(block_count[i][0])
    right.append(block_count[i][1])

  return left, right, trial_list